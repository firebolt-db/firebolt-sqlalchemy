{"uid":"40b0430be6a7506b","name":"test_core_simple_query","fullName":"tests.integration.test_core_integration.TestFireboltCoreIntegration#test_core_simple_query","historyId":"2f484025ca4d94baeb1fe3a1622667a2","time":{"start":1751991243649,"stop":1751991243651,"duration":2},"description":"Test executing a simple query against Core.","descriptionHtml":"<p>Test executing a simple query against Core.</p>\n","status":"broken","statusMessage":"httpx.ConnectError: [Errno 111] Connection refused","statusTrace":"@contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        global HTTPCORE_EXC_MAP\n        if len(HTTPCORE_EXC_MAP) == 0:\n            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.KeepaliveTransport object at 0x7f32fa01af70>\nrequest = <Request('POST', 'http://localhost:3473/?database=firebolt&output_format=JSON_Compact')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n        import httpcore\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:250: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n                    response = connection.handle_request(\n                        pool_request.request\n                    )\n                except ConnectionNotAvailable:\n                    # In some cases a connection may initially be available to\n                    # handle a request, but then become unavailable.\n                    #\n                    # In this case we clear the connection and try again.\n                    pool_request.clear_connection()\n                else:\n                    break  # pragma: nocover\n    \n        except BaseException as exc:\n            with self._optional_thread_lock:\n                # For any exception or cancellation we remove the request from\n                # the queue, and then re-assign requests to connections.\n                self._requests.remove(pool_request)\n                closing = self._assign_requests_to_connections()\n    \n            self._close_connections(closing)\n>           raise exc from None\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection_pool.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n>                   response = connection.handle_request(\n                        pool_request.request\n                    )\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection_pool.py:236: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n        except BaseException as exc:\n            self._connect_failed = True\n>           raise exc\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n>                   stream = self._connect(request)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def _connect(self, request: Request) -> NetworkStream:\n        timeouts = request.extensions.get(\"timeout\", {})\n        sni_hostname = request.extensions.get(\"sni_hostname\", None)\n        timeout = timeouts.get(\"connect\", None)\n    \n        retries_left = self._retries\n        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)\n    \n        while True:\n            try:\n                if self._uds is None:\n                    kwargs = {\n                        \"host\": self._origin.host.decode(\"ascii\"),\n                        \"port\": self._origin.port,\n                        \"local_address\": self._local_address,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\"connect_tcp\", logger, request, kwargs) as trace:\n>                       stream = self._network_backend.connect_tcp(**kwargs)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:124: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.OverriddenHttpBackend object at 0x7f32f9e460a0>\nargs = ()\nkwargs = {'host': 'localhost', 'local_address': None, 'port': 3473, 'socket_options': None, ...}\n\n    def connect_tcp(self, *args, **kwargs):  # type: ignore\n>       stream = super().connect_tcp(*args, **kwargs)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/client/http_backend.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.OverriddenHttpBackend object at 0x7f32f9e460a0>\nhost = 'localhost', port = 3473, timeout = 60, local_address = None\nsocket_options = []\n\n    def connect_tcp(\n        self,\n        host: str,\n        port: int,\n        timeout: float | None = None,\n        local_address: str | None = None,\n        socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n    ) -> NetworkStream:\n        # Note that we automatically include `TCP_NODELAY`\n        # in addition to any other custom socket options.\n        if socket_options is None:\n            socket_options = []  # pragma: no cover\n        address = (host, port)\n        source_address = None if local_address is None else (local_address, 0)\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n    \n        with map_exceptions(exc_map):\n            sock = socket.create_connection(\n                address,\n                timeout,\n                source_address=source_address,\n            )\n            for option in socket_options:\n                sock.setsockopt(*option)  # pragma: no cover\n>           sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_backends/sync.py:215: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7f32f9282c10>\ntype = <class 'ConnectionRefusedError'>\nvalue = ConnectionRefusedError(111, 'Connection refused')\ntraceback = <traceback object at 0x7f32f94c9140>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/contextlib.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'socket.timeout'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc) from exc\nE                   httpcore.ConnectError: [Errno 111] Connection refused\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_exceptions.py:14: ConnectError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_core_integration.TestFireboltCoreIntegration object at 0x7f32fa10f580>\ncore_connection = <sqlalchemy.engine.base.Connection object at 0x7f32fa01ac40>\n\n    def test_core_simple_query(self, core_connection: Connection):\n        \"\"\"Test executing a simple query against Core.\"\"\"\n>       result = core_connection.execute(text(\"SELECT 'Hello Core' as message\"))\n\ntests/integration/test_core_integration.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1415: in execute\n    return meth(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection\n    return connection._execute_clauseelement(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement\n    ret = self._execute_context(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context\n    return self._exec_single_context(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context\n    self._handle_dbapi_exception(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2354: in _handle_dbapi_exception\n    raise exc_info[1].with_traceback(exc_info[2])\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context\n    self.dialect.do_execute(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt_db/firebolt_dialect.py:395: in do_execute\n    cursor.execute(statement, parameters=parameters)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/common/cursor/decorators.py:24: in inner\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/db/cursor.py:338: in execute\n    self._do_execute(query, params_list, skip_parsing, timeout=timeout_seconds)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/db/cursor.py:238: in _do_execute\n    self._execute_single_query(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/db/cursor.py:265: in _execute_single_query\n    self._handle_query_execution(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/db/cursor.py:289: in _handle_query_execution\n    resp = self._api_request(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/db/cursor.py:159: in _api_request\n    return self._client.send(req, stream=True)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:914: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:942: in _send_handling_auth\n    response = self._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/firebolt/client/client.py:123: in _send_handling_redirects\n    return super()._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:979: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:1014: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:250: in handle_request\n    resp = self._pool.handle_request(req)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/contextlib.py:131: in __exit__\n    self.gen.throw(type, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        global HTTPCORE_EXC_MAP\n        if len(HTTPCORE_EXC_MAP) == 0:\n            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()\n        try:\n            yield\n        except Exception as exc:\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ConnectError: [Errno 111] Connection refused\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:118: ConnectError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"core_url","time":{"start":1751991240613,"stop":1751991240613,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_engine","time":{"start":1751991240614,"stop":1751991240641,"duration":27},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_connection","time":{"start":1751991240642,"stop":1751991240720,"duration":78},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"client_id","time":{"start":1751991240721,"stop":1751991240722,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"database_name","time":{"start":1751991240722,"stop":1751991240723,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"client_key","time":{"start":1751991240722,"stop":1751991240722,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"engine","time":{"start":1751991240723,"stop":1751991240742,"duration":19},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"account_name","time":{"start":1751991240723,"stop":1751991240723,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"engine_name","time":{"start":1751991240723,"stop":1751991240723,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"connection","time":{"start":1751991240742,"stop":1751991241886,"duration":1144},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"firebolt_columns","time":{"start":1751991241887,"stop":1751991241887,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"setup_test_tables","time":{"start":1751991241887,"stop":1751991243385,"duration":1498},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"type_table_name","time":{"start":1751991241887,"stop":1751991241887,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"dimension_table_name","time":{"start":1751991241887,"stop":1751991241887,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"fact_table_name","time":{"start":1751991241887,"stop":1751991241887,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"type_table_query","time":{"start":1751991241887,"stop":1751991241887,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"afterStages":[{"name":"setup_test_tables::0","time":{"start":1751991243905,"stop":1751991244613,"duration":708},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"connection::0","time":{"start":1751991252447,"stop":1751991252447,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_connection::0","time":{"start":1751991252455,"stop":1751991252455,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"parentSuite","value":"tests.integration"},{"name":"suite","value":"test_core_integration"},{"name":"subSuite","value":"TestFireboltCoreIntegration"},{"name":"host","value":"pkrvmbietmlfzoi"},{"name":"thread","value":"2767-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.integration.test_core_integration"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"40b0430be6a7506b.json","parameterValues":[]}